\section{3D Visualization Pipeline}
\label{sec.visualization_pipeline}

%This section reviews the viewing transform used by most popular graphics frameworks such as OpenGL. 

%Yet there is no standard way to specify the view, and there are a wide range of different viewing implementations currently in use.

%Closely tied in to viewing parameters is 3D interaction, and there are likewise a large number of different 3D interaction implementations often providing the same basic functionality. Users are forced to learn and use different pan, zoom, and spin techniques for each 3D program they use. As every 3D program has to reinvent this functionality,  OpenGL standard has emerged to supply the lack of standardization, the need of higher development and support efforts; as well as stifling the proliferation of user interface features like stereo. A standard viewing software toolkit, along with a standard motion toolkit, would benefit end users by delivering consistent and comprehensive 3D interaction across applications, and would benefit developers by reducing development time, software support, and customer support. All of the various interaction techniques can be provided to satisfy the varying requirements of the different types of 3D programs and the different levels of end user expertise.

The generation of 3D computer graphics is essentially a straightforward mapping of graphical items in a 3D volume, in a spatial domain $S$ in $\Re^3$, to a 2D image, in a spatial domain $S^{\prime}$ in $\Re^2$. Most viewing software use different transforms combined to deliver consistent and comprehensive 3D interactions: the model transform represents affine transformations, scale, translation and rotation, of each object in the 3D scene in the mapping $M_{model}: S_{model} \Rightarrow S_{scene}$; the view transform represents the individual transformations of every object in the 3D scene, representing the scene positioning for the viewer; which is the mapping $M_{view}: S_{view} \Rightarrow S_{scene}$; and the projection transform is the mapping $M_{proj}:S_{view} \Rightarrow S_{proj}$ that represents the perception of depth of the eye or camera. The final transform to 2D screen coordinates is $M_{screen}:S_{proj} \Rightarrow S^{\prime}_{screen}$. Note that in $M_{model}$ and $M_{view}$ the mapping is inverted to preserve the original spatial domain. Without loose of generality, all mappings can be defined as matrix transforms.

%The combination of the first and second transforms, view and model, is a single transform that translates and rotates the scene accordingly the viewer position, looking direction and view roll. This is an affine transform and the inverse  transform exists. Both transforms can be easily computed as a matrix in homogeneous coordinates. The latter transform projects the 3D scene into the output image. In most cases, the output image is a rectangular shape and the 3D view volume, called frustum, which is either a rectangular prism or a truncated pyramid for parallel and perspective views, respectively.


\input{sec_visualization_opengl}

\input{sec_visualization_stereo}